
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/caffinatedmonkey/dos/game/cards.go (100.0%)</option>
				
				<option value="file1">github.com/caffinatedmonkey/dos/game/game.go (59.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package dos

import (
        "math/rand"
        "sync"

        proto "github.com/caffinatedmonkey/dos/proto"
        "github.com/caffinatedmonkey/dos/utils"
)

type Cards struct {
        List []proto.Card

        Deletions utils.Broadcaster
        Additions utils.Broadcaster

        sync.RWMutex
}

func NewCardCollection() *Cards <span class="cov8" title="1">{
        return &amp;Cards{
                List:      []proto.Card{},
                Additions: *utils.NewBroadcaster(),
                Deletions: *utils.NewBroadcaster(),
        }
}</span>

func (ol *Cards) Push(e ...proto.Card) <span class="cov8" title="1">{
        ol.RWMutex.Lock()
        defer ol.RWMutex.Unlock()

        ol.List = append(ol.List, e...)
        for _, elem := range e </span><span class="cov8" title="1">{
                ol.Additions.Broadcast(elem)
        }</span>
}

func (cards *Cards) PushFront(newCards ...proto.Card) <span class="cov8" title="1">{
        cards.RWMutex.Lock()
        defer cards.RWMutex.Unlock()

        cards.List = append(newCards, cards.List...)
        for _, card := range newCards </span><span class="cov8" title="1">{
                cards.Additions.Broadcast(card)
        }</span>
}

// Removes and returns the last element of the array. If the array is empty,
// returns nil.
func (ol *Cards) Pop() proto.Card <span class="cov8" title="1">{
        return ol.PopN(1)[0]
}</span>

// Removes and returns the last n elements of the array.
func (ol *Cards) PopN(n int) []proto.Card <span class="cov8" title="1">{
        ol.RWMutex.Lock()
        defer ol.RWMutex.Unlock()

        lengthBefore := len(ol.List)
        lastElementIndex := lengthBefore - n
        if lastElementIndex &lt; 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Get Last n Elements
        <span class="cov8" title="1">elems := ol.List[lastElementIndex:]

        for index := range elems </span><span class="cov8" title="1">{
                ol.Deletions.Broadcast(elems[index].Id)
        }</span>

        // Remove Last n Elements
        <span class="cov8" title="1">ol.List = ol.List[:lastElementIndex]

        return elems</span>
}

func (cards *Cards) PopFront(n int) []proto.Card <span class="cov8" title="1">{
        if n &gt; len(cards.List) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">cards.RWMutex.Lock()
        defer cards.RWMutex.Unlock()

        removing := cards.List[:n]
        cards.List = cards.List[n:]

        for index := range removing </span><span class="cov8" title="1">{
                cards.Deletions.Broadcast(removing[index].Id)
        }</span>

        <span class="cov8" title="1">return removing</span>
}

// Shuffles the underlying list using a fisher yates shuffle.
func (cards *Cards) Shuffle() <span class="cov8" title="1">{
        cards.RWMutex.Lock()
        defer cards.RWMutex.Unlock()

        currentIndex := len(cards.List)

        for currentIndex &gt; 0 </span><span class="cov8" title="1">{
                randomIndex := rand.Intn(currentIndex)
                currentIndex = currentIndex - 1
                swap(currentIndex, randomIndex, cards.List)
        }</span>
}

func (cards *Cards) FindById(id int32) (*proto.Card, int) <span class="cov8" title="1">{
        cards.RWMutex.RLock()
        defer cards.RWMutex.RUnlock()
        for index := range cards.List </span><span class="cov8" title="1">{
                card := &amp;cards.List[index]
                if card.Id == id </span><span class="cov8" title="1">{
                        return card, index
                }</span>
        }

        <span class="cov8" title="1">return nil, -1</span>
}

func (cards *Cards) RemoveCard(index int) <span class="cov8" title="1">{
        cards.RWMutex.Lock()
        defer cards.RWMutex.Unlock()

        deleting := cards.List[index]
        cards.List = append(cards.List[:index], cards.List[index+1:]...)
        cards.Deletions.Broadcast(deleting.Id)
}</span>

// func (cards *Cards) PopId(id int32) *proto.Card {
//         cards.RWMutex.Lock()
//         defer cards.RWMutex.Unlock()
//
//         newCards := make([]proto.Card, len(cards.List))
//         var foundCard *proto.Card
//         i := 0
//         for index := range cards.List {
//                 card := cards.List[index]
//                 if card.Id == id {
//                         foundCard = &amp;card
//                 } else {
//                         newCards[i] = card
//                         i++
//                 }
//         }
//
//         cards.List = newCards
//         if foundCard != nil {
//                 cards.Deletions.Broadcast(foundCard.Id)
//         }
//
//         return foundCard
// }

func swap(f, t int, array []proto.Card) <span class="cov8" title="1">{
        array[t], array[f] = array[f], array[t]
}</span>

// func (ol *Cards) GetElement(index int) interface{} {
//         if index &lt;= len(ol.list)-1 {
//                 return ol.list[index]
//         } else {
//                 panic("Index out of bounds")
//         }
// }

// Creates a new deck and populates it with the standard playing cards
func PlayingDeck() *Cards <span class="cov8" title="1">{
        deck := NewCardCollection()
        deck.Populate()
        deck.Shuffle()
        return deck
}</span>

var CardColors = []proto.CardColor{
        proto.CardColor_RED,
        proto.CardColor_YELLOW,
        proto.CardColor_GREEN,
        proto.CardColor_BLUE,
}

// Add the standard cards to the deck.
func (cards *Cards) Populate() <span class="cov8" title="1">{
        id := int32(0)
        for i := 0; i &lt; 2; i++ </span><span class="cov8" title="1">{
                for _, color := range CardColors </span><span class="cov8" title="1">{
                        // Insert Cards 1-9
                        for k := int32(1); k &lt; int32(10); k++ </span><span class="cov8" title="1">{
                                id++
                                cards.Push(proto.Card{
                                        Id:     id,
                                        Number: k,
                                        Color:  color,
                                        Type:   proto.CardType_NORMAL,
                                })
                        }</span>

                        // Insert Special Cards (Skip, Reverse, DoubleDraw)
                        <span class="cov8" title="1">id++
                        cards.Push(proto.Card{
                                Id:     id,
                                Number: -1,
                                Color:  color,
                                Type:   proto.CardType_SKIP,
                        })

                        id++
                        cards.Push(proto.Card{
                                Id:     id,
                                Number: -1,
                                Color:  color,
                                Type:   proto.CardType_REVERSE,
                        })

                        id++
                        cards.Push(proto.Card{
                                Id:     id,
                                Number: -1,
                                Color:  color,
                                Type:   proto.CardType_DOUBLEDRAW,
                        })

                        if i == 0 </span><span class="cov8" title="1">{
                                id++
                                cards.Push(proto.Card{
                                        Id:     id,
                                        Number: -1,
                                        Color:  proto.CardColor_BLACK,
                                        Type:   proto.CardType_QUADDRAW,
                                })

                                id++
                                cards.Push(proto.Card{
                                        Id:     id,
                                        Number: 0,
                                        Color:  color,
                                        Type:   proto.CardType_NORMAL,
                                })
                        }</span><span class="cov8" title="1"> else if i == 1 </span><span class="cov8" title="1">{
                                id++
                                cards.Push(proto.Card{
                                        Id:     id,
                                        Number: -1,
                                        Color:  proto.CardColor_BLACK,
                                        Type:   proto.CardType_WILD,
                                })
                        }</span>
                }
        }
}

func CanCoverCard(baseCard, otherCard *proto.Card) bool <span class="cov8" title="1">{
        specialsMatch := baseCard.Type == otherCard.Type
        bothAreNormal := specialsMatch &amp;&amp; baseCard.Type == proto.CardType_NORMAL

        colorsMatch := baseCard.Color == otherCard.Color
        numbersMatch := baseCard.Number == otherCard.Number

        if colorsMatch || (numbersMatch &amp;&amp; bothAreNormal) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">bothAreNotNormal := specialsMatch &amp;&amp; baseCard.Type != proto.CardType_NORMAL
        if specialsMatch &amp;&amp; bothAreNotNormal </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if baseCard.Color == proto.CardColor_BLACK </span><span class="cov8" title="1">{
                // If the game starts with a black card, anything can cover it.
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package dos

import (
        "errors"
        // "log"
        "math/rand"
        "sync"

        proto "github.com/caffinatedmonkey/dos/proto"
        "github.com/caffinatedmonkey/dos/utils"
)

type Player struct {
        Name string
        Cards
        TurnDone chan interface{}
}

type Game struct {
        // TODO: Thread safe reading
        playerMutex sync.Mutex
        players     []*Player

        Discard Cards
        Deck    Cards

        PlayerJoined utils.Broadcaster
        PlayerLeft   utils.Broadcaster
        Turn         utils.Broadcaster

        currentPlayerIndex int
        isReversed         bool

        // Whether the action card of the action card at the top of the discard pile
        // has been executed.
        lastCardPlayed bool
}

// Creates a new game an initalizes its values
func NewGame() *Game <span class="cov8" title="1">{
        // Initalize Values
        g := Game{
                players:      []*Player{},
                Deck:         *PlayingDeck(),
                PlayerJoined: *utils.NewBroadcaster(),
                PlayerLeft:   *utils.NewBroadcaster(),
                Turn:         *utils.NewBroadcaster(),

                currentPlayerIndex: -1,
                // lastPlayerPlayed:   true,
        }

        g.Discard.Push(g.Deck.Pop())
        return &amp;g
}</span>

// Creates a new player, populates its deck and adds it to the game
func (game *Game) NewPlayer(name string) (*Player, error) <span class="cov8" title="1">{
        for _, player := range game.players </span><span class="cov8" title="1">{
                if player.Name == name </span><span class="cov0" title="0">{
                        return nil, errors.New("Player already exists in game")
                }</span>
        }

        <span class="cov8" title="1">player := &amp;Player{
                Cards:    *NewCardCollection(),
                Name:     name,
                TurnDone: make(chan interface{}),
        }
        game.DrawCards(&amp;player.Cards, 8)

        game.playerMutex.Lock()
        game.players = append(game.players, player)
        game.playerMutex.Unlock()

        // Inform Listeners
        game.PlayerJoined.Broadcast(name)

        return player, nil</span>
}

func (game *Game) RemovePlayer(removing *Player) <span class="cov0" title="0">{
        game.playerMutex.Lock()

        // Remove Player
        i := 0
        newPlayers := make([]*Player, len(game.players))
        for _, player := range game.players </span><span class="cov0" title="0">{
                if player != removing </span><span class="cov0" title="0">{
                        i++
                        newPlayers[i] = player
                }</span>
        }

        <span class="cov0" title="0">game.players = newPlayers
        game.playerMutex.Unlock()

        // Return to discard pile
        game.Discard.PushFront(removing.Cards.List...)

        // Notify Players
        game.PlayerLeft.Broadcast(removing.Name)</span>
}

func (game *Game) GetPlayerList() []string <span class="cov0" title="0">{
        result := make([]string, len(game.players))
        i := 0
        for _, player := range game.players </span><span class="cov0" title="0">{
                result[i] = player.Name
                i++
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Called after a player completes their turn. Get's the player who is to play
// next.
func (game *Game) NextPlayer() *Player <span class="cov8" title="1">{
        // If this is the first turn, pick a random player
        if game.currentPlayerIndex == -1 </span><span class="cov8" title="1">{
                game.currentPlayerIndex = rand.Intn(len(game.players) - 1)
                return game.players[game.currentPlayerIndex]
        }</span>

        <span class="cov8" title="1">increment := 1

        if !game.lastCardPlayed </span><span class="cov8" title="1">{
                // Don't handle special actions more than once.
                lastCard := game.Discard.List[len(game.Discard.List)-1]

                switch lastCard.Type </span>{
                <span class="cov0" title="0">case proto.CardType_REVERSE:
                        game.isReversed = !game.isReversed
                        if len(game.players) == 2 </span><span class="cov0" title="0">{
                                increment += 1
                        }</span>

                <span class="cov8" title="1">case proto.CardType_SKIP:
                        increment += 1</span>

                <span class="cov0" title="0">case proto.CardType_DOUBLEDRAW:
                        increment += 1
                        player, _ := game.GetPlayer(1)
                        game.DrawCards(&amp;player.Cards, 2)</span>

                <span class="cov0" title="0">case proto.CardType_QUADDRAW:
                        increment += 1
                        player, _ := game.GetPlayer(1)
                        game.DrawCards(&amp;player.Cards, 4)</span>

                }

                <span class="cov8" title="1">game.lastCardPlayed = true</span>
        }

        <span class="cov8" title="1">nextPlayer, index := game.GetPlayer(increment)
        game.currentPlayerIndex = index
        return nextPlayer</span>
}

// Gets the player index n positions away from the current player.
func (game *Game) GetPlayer(n int) (*Player, int) <span class="cov8" title="1">{
        if game.isReversed </span><span class="cov0" title="0">{
                n *= -1
        }</span>

        <span class="cov8" title="1">playersCount := len(game.players)

        // This modulo operator isn't the same as the mathematical modulo operator.
        // It returns negative values when the left side is negative.
        current := (game.currentPlayerIndex + n) % playersCount
        if current &lt; 0 </span><span class="cov8" title="1">{
                current += playersCount
        }</span>

        <span class="cov8" title="1">return game.players[current], current</span>
}

func (game *Game) PlayCard(player *Player, id int32, color proto.CardColor) error <span class="cov8" title="1">{
        card, index := player.Cards.FindById(id)
        if card == nil </span><span class="cov0" title="0">{
                return errors.New("Card is not owned by player")
        }</span>

        // Check If Card Is Valid
        <span class="cov8" title="1">lastDiscard := &amp;game.Discard.List[len(game.Discard.List)-1]
        canCover := CanCoverCard(lastDiscard, card)
        if !canCover </span><span class="cov0" title="0">{
                return errors.New("You can't play that card")
        }</span>

        // Set Color If Needed
        <span class="cov8" title="1">if card.Color == proto.CardColor_BLACK </span><span class="cov0" title="0">{
                card.Color = color
        }</span>

        <span class="cov8" title="1">game.lastCardPlayed = false
        game.Discard.Push(*card)
        player.Cards.RemoveCard(index)
        return nil</span>
}

// Draws count cards into hand. Recycle's cards if needed
func (game *Game) DrawCards(hand *Cards, count int) <span class="cov8" title="1">{
        if count &gt; len(game.Deck.List) </span><span class="cov8" title="1">{
                // Not enough cards to draw. Recycle entire discard pile.
                recyclable := game.Discard.PopFront(len(game.Discard.List) - 1)
                game.Deck.Push(recyclable...)
                game.Deck.Shuffle()
        }</span>

        <span class="cov8" title="1">if count &gt; len(game.Deck.List) </span><span class="cov0" title="0">{
                // TODO: Handle
                panic("Too many players. Not enough cards.")</span>
        }

        <span class="cov8" title="1">cards := game.Deck.PopN(count)
        hand.Push(cards...)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
